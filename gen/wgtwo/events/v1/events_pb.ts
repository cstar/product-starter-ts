// Copyright 2021 Working Group Two AS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file wgtwo/events/v1/events.proto (package wgtwo.events.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Empty, Message, proto3, Timestamp } from "@bufbuild/protobuf";
import { SubscriptionIdentifier } from "../../common/v1/types_pb.js";

/**
 * This is the configuration for setting up a event stream from our APIs.
 *
 * The client will be forced to reconnect after one hour to ensure it is using fresh access tokens.
 *
 * The default settings should be well suited for production usage, but 'max_in_flight' may be tweaked.
 *
 * Regular:
 *   Warning: This is intended for testing purposes only and is not recommended for production.
 *
 *   All connected clients will see all events in the stream.
 *   Reading position is not stored at the server, so disconnecting will make it start fresh.
 *
 * Durable Queue:
 *   All connected clients with the same name will share the stream, so that an event will only be seen be a single
 *   client.
 *
 *   The server will store the clients reading position for 1 hour after the client has disconnected.
 *   That would make it possible for a client to resume reading after it has been disconnected.
 *
 *    Note:
 *     - The custom_name is namespaced to be per OAuth 2.0 client, so using the same name for two different OAuth 2.0
 *       clients will not make them part of the same stream.
 *
 *    Example:
 *      Giving the following configuration, you may get approximately the distribution shown below:
 *        3 × custom_name = "" (default)
 *        2 × custom_name = "alice"
 *        1 × custom_name = "bob"
 *
 *            ┌─►33 % ─► ""
 *      ─ ─ ──┼─►33 % ─► ""
 *            └─►33 % ─► ""
 *      ─ ─ ──┬─►50 % ─► "alice"
 *            └─►50 % ─► "alice"
 *      ─ ─ ────►100 ──► "bob"
 *
 * Acknowledge:
 *   The server will for the client to sent a ack message. If no such message has been received within 30 seconds,
 *   the event will be resent.
 *
 * Max in-flight:
 *   The server will only allow, by default, 50 in-flight unacknowledged events.
 *   In combination with requiring acks, this allows the client to apply some backpressure.
 *
 *   Note that max in-flight > 1 may cause events to be received out-of-order, something the client must design for.
 *
 * Start Position:
 *   This decides the policy used when a client connects without having its reading position stored at the server.
 *   The start position may be set to
 *   - only include new events (events created after connection)
 *   - a specific ID
 *   - starting at a given time
 *   - deliver all available events
 *
 *
 * All settings are optional, with the following set as default:
 *
 * - Events are load balanced between all connected clients using the same OAuth 2.0 client
 *
 * - Current reading position is remembered on the server for 1 hour, even if no clients are connected
 *   That is, reading may resume even if the clients needs to disconnect
 *
 * - The clients needs to send a ack after processing a event
 *   If a client does not ack within 30 seconds, the event will be resent
 *
 * - 50 un-acknowledged events will be allowed at once
 *
 * - If reading position is not stored in server, that is on first connection or if all clients has been gone for
 *   30 minutes, only new events will be included.
 *
 * @generated from message wgtwo.events.v1.StreamConfiguration
 */
export class StreamConfiguration extends Message<StreamConfiguration> {
  /**
   * Optional: Will use DurableQueue by default
   *
   * @generated from oneof wgtwo.events.v1.StreamConfiguration.stream_type
   */
  streamType: {
    /**
     * @generated from field: wgtwo.events.v1.RegularStream regular = 1;
     */
    value: RegularStream;
    case: "regular";
  } | {
    /**
     * @generated from field: wgtwo.events.v1.DurableQueue durable_queue = 2;
     */
    value: DurableQueue;
    case: "durableQueue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Optional: By default, the client is required to send a ack message and will use a timeout of 30 seconds.
   *
   * @generated from oneof wgtwo.events.v1.StreamConfiguration.acknowledge_option
   */
  acknowledgeOption: {
    /**
     * Disable ack
     *
     * @generated from field: google.protobuf.Empty disable_explicit_ack = 3;
     */
    value: Empty;
    case: "disableExplicitAck";
  } | {
    /**
     * Must be between 10 seconds and 10 minutes
     *
     * @generated from field: google.protobuf.Duration custom_ack_timeout = 4;
     */
    value: Duration;
    case: "customAckTimeout";
  } | { case: undefined; value?: undefined } = { case: undefined };

  /**
   * Optional: By default, max 50 unacknowledged events may be in-flight
   * Must be between 1 and 200
   *
   * @generated from field: uint32 max_in_flight = 5;
   */
  maxInFlight = 0;

  /**
   * Optional: By default, only new events will be included
   *
   * @generated from oneof wgtwo.events.v1.StreamConfiguration.start_position
   */
  startPosition: {
    /**
     * Will only deliver events generated after this subscription was started
     *
     * @generated from field: uint64 start_at_new = 6;
     */
    value: bigint;
    case: "startAtNew";
  } | {
    /**
     * Will deliver events from the given ID
     *
     * @generated from field: uint64 start_at_id = 7;
     */
    value: bigint;
    case: "startAtId";
  } | {
    /**
     * Will deliver events from the given timestamp
     *
     * @generated from field: google.protobuf.Timestamp start_at_timestamp = 8;
     */
    value: Timestamp;
    case: "startAtTimestamp";
  } | {
    /**
     * Will deliver all available events
     *
     * @generated from field: google.protobuf.Empty start_at_oldest_possible = 9;
     */
    value: Empty;
    case: "startAtOldestPossible";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<StreamConfiguration>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.StreamConfiguration";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "regular", kind: "message", T: RegularStream, oneof: "stream_type" },
    { no: 2, name: "durable_queue", kind: "message", T: DurableQueue, oneof: "stream_type" },
    { no: 3, name: "disable_explicit_ack", kind: "message", T: Empty, oneof: "acknowledge_option" },
    { no: 4, name: "custom_ack_timeout", kind: "message", T: Duration, oneof: "acknowledge_option" },
    { no: 5, name: "max_in_flight", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 6, name: "start_at_new", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "start_position" },
    { no: 7, name: "start_at_id", kind: "scalar", T: 4 /* ScalarType.UINT64 */, oneof: "start_position" },
    { no: 8, name: "start_at_timestamp", kind: "message", T: Timestamp, oneof: "start_position" },
    { no: 9, name: "start_at_oldest_possible", kind: "message", T: Empty, oneof: "start_position" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): StreamConfiguration {
    return new StreamConfiguration().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): StreamConfiguration {
    return new StreamConfiguration().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): StreamConfiguration {
    return new StreamConfiguration().fromJsonString(jsonString, options);
  }

  static equals(a: StreamConfiguration | PlainMessage<StreamConfiguration> | undefined, b: StreamConfiguration | PlainMessage<StreamConfiguration> | undefined): boolean {
    return proto3.util.equals(StreamConfiguration, a, b);
  }
}

/**
 * All connected clients will see all events in the stream.
 * Reading position is not stored at the server, so disconnecting will make it start fresh.
 *
 * @generated from message wgtwo.events.v1.RegularStream
 */
export class RegularStream extends Message<RegularStream> {
  constructor(data?: PartialMessage<RegularStream>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.RegularStream";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RegularStream {
    return new RegularStream().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RegularStream {
    return new RegularStream().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RegularStream {
    return new RegularStream().fromJsonString(jsonString, options);
  }

  static equals(a: RegularStream | PlainMessage<RegularStream> | undefined, b: RegularStream | PlainMessage<RegularStream> | undefined): boolean {
    return proto3.util.equals(RegularStream, a, b);
  }
}

/**
 * All connected clients with the same name will share the stream, so that an event will only be seen be a single
 * client.
 *
 * The server will store the clients reading position for 1 hour after the client has disconnected.
 * That would make it possible for a client to resume reading after it has been disconnected.
 *
 * If e.g. five group of clients should see all events in the stream, each group must be given a unique name.
 *
 * @generated from message wgtwo.events.v1.DurableQueue
 */
export class DurableQueue extends Message<DurableQueue> {
  /**
   * Optional: Messages will by default be shared between all connections using the same OAuth 2.0 client
   *
   * @generated from field: string custom_name = 1;
   */
  customName = "";

  constructor(data?: PartialMessage<DurableQueue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.DurableQueue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "custom_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DurableQueue {
    return new DurableQueue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DurableQueue {
    return new DurableQueue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DurableQueue {
    return new DurableQueue().fromJsonString(jsonString, options);
  }

  static equals(a: DurableQueue | PlainMessage<DurableQueue> | undefined, b: DurableQueue | PlainMessage<DurableQueue> | undefined): boolean {
    return proto3.util.equals(DurableQueue, a, b);
  }
}

/**
 * This contains a opaque string which should be included in the ack request to identify the event
 *
 * @generated from message wgtwo.events.v1.AckInfo
 */
export class AckInfo extends Message<AckInfo> {
  /**
   * @generated from field: string value = 1;
   */
  value = "";

  constructor(data?: PartialMessage<AckInfo>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.AckInfo";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AckInfo {
    return new AckInfo().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AckInfo {
    return new AckInfo().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AckInfo {
    return new AckInfo().fromJsonString(jsonString, options);
  }

  static equals(a: AckInfo | PlainMessage<AckInfo> | undefined, b: AckInfo | PlainMessage<AckInfo> | undefined): boolean {
    return proto3.util.equals(AckInfo, a, b);
  }
}

/**
 * Status of the ack request
 *
 * If status is not successful, the ack request may be retried.
 * Everything except AckStatusCodeACK_STATUS_SUCCESS should be treated as a failure
 *
 * @generated from message wgtwo.events.v1.AckStatus
 */
export class AckStatus extends Message<AckStatus> {
  /**
   * @generated from field: wgtwo.events.v1.AckStatus.StatusCode status_code = 1;
   */
  statusCode = AckStatus_StatusCode.UNSPECIFIED;

  constructor(data?: PartialMessage<AckStatus>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.AckStatus";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "status_code", kind: "enum", T: proto3.getEnumType(AckStatus_StatusCode) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AckStatus {
    return new AckStatus().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AckStatus {
    return new AckStatus().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AckStatus {
    return new AckStatus().fromJsonString(jsonString, options);
  }

  static equals(a: AckStatus | PlainMessage<AckStatus> | undefined, b: AckStatus | PlainMessage<AckStatus> | undefined): boolean {
    return proto3.util.equals(AckStatus, a, b);
  }
}

/**
 * @generated from enum wgtwo.events.v1.AckStatus.StatusCode
 */
export enum AckStatus_StatusCode {
  /**
   * @generated from enum value: STATUS_CODE_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * @generated from enum value: STATUS_CODE_FAILURE = 1;
   */
  FAILURE = 1,

  /**
   * @generated from enum value: STATUS_CODE_SUCCESS = 2;
   */
  SUCCESS = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(AckStatus_StatusCode)
proto3.util.setEnumType(AckStatus_StatusCode, "wgtwo.events.v1.AckStatus.StatusCode", [
  { no: 0, name: "STATUS_CODE_UNSPECIFIED" },
  { no: 1, name: "STATUS_CODE_FAILURE" },
  { no: 2, name: "STATUS_CODE_SUCCESS" },
]);

/**
 * Ack request, which is required for sending a ack of an event
 *
 * @generated from message wgtwo.events.v1.AckRequest
 */
export class AckRequest extends Message<AckRequest> {
  /**
   * @generated from field: wgtwo.events.v1.AckInfo ack_info = 1;
   */
  ackInfo?: AckInfo;

  constructor(data?: PartialMessage<AckRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.AckRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ack_info", kind: "message", T: AckInfo },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AckRequest {
    return new AckRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AckRequest {
    return new AckRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AckRequest {
    return new AckRequest().fromJsonString(jsonString, options);
  }

  static equals(a: AckRequest | PlainMessage<AckRequest> | undefined, b: AckRequest | PlainMessage<AckRequest> | undefined): boolean {
    return proto3.util.equals(AckRequest, a, b);
  }
}

/**
 * This response includes the status of the ack request
 *
 * @generated from message wgtwo.events.v1.AckResponse
 */
export class AckResponse extends Message<AckResponse> {
  /**
   * @generated from field: wgtwo.events.v1.AckStatus ack_status = 1;
   */
  ackStatus?: AckStatus;

  constructor(data?: PartialMessage<AckResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.AckResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "ack_status", kind: "message", T: AckStatus },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AckResponse {
    return new AckResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AckResponse {
    return new AckResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AckResponse {
    return new AckResponse().fromJsonString(jsonString, options);
  }

  static equals(a: AckResponse | PlainMessage<AckResponse> | undefined, b: AckResponse | PlainMessage<AckResponse> | undefined): boolean {
    return proto3.util.equals(AckResponse, a, b);
  }
}

/**
 * Identity of the subscription this event was generated for.
 *
 * @generated from message wgtwo.events.v1.Identifier
 */
export class Identifier extends Message<Identifier> {
  /**
   * @generated from field: wgtwo.common.v1.SubscriptionIdentifier subscription_identifier = 1;
   */
  subscriptionIdentifier?: SubscriptionIdentifier;

  constructor(data?: PartialMessage<Identifier>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.Identifier";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "subscription_identifier", kind: "message", T: SubscriptionIdentifier },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Identifier {
    return new Identifier().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Identifier {
    return new Identifier().fromJsonString(jsonString, options);
  }

  static equals(a: Identifier | PlainMessage<Identifier> | undefined, b: Identifier | PlainMessage<Identifier> | undefined): boolean {
    return proto3.util.equals(Identifier, a, b);
  }
}

/**
 * Metadata about the event
 *
 * @generated from message wgtwo.events.v1.Metadata
 */
export class Metadata extends Message<Metadata> {
  /**
   * The timestamp this event was generated
   *
   * @generated from field: google.protobuf.Timestamp timestamp = 1;
   */
  timestamp?: Timestamp;

  /**
   * Identity of the subscription this event was generated for.
   *
   * @generated from field: wgtwo.events.v1.Identifier identifier = 2;
   */
  identifier?: Identifier;

  /**
   * Information that must be included in the ack request to identify the event
   *
   * @generated from field: wgtwo.events.v1.AckInfo ack_info = 3;
   */
  ackInfo?: AckInfo;

  /**
   * True when this is not the first time the message has been sent
   *
   * @generated from field: bool is_redelivered = 4;
   */
  isRedelivered = false;

  constructor(data?: PartialMessage<Metadata>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.events.v1.Metadata";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "timestamp", kind: "message", T: Timestamp },
    { no: 2, name: "identifier", kind: "message", T: Identifier },
    { no: 3, name: "ack_info", kind: "message", T: AckInfo },
    { no: 4, name: "is_redelivered", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Metadata {
    return new Metadata().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Metadata {
    return new Metadata().fromJsonString(jsonString, options);
  }

  static equals(a: Metadata | PlainMessage<Metadata> | undefined, b: Metadata | PlainMessage<Metadata> | undefined): boolean {
    return proto3.util.equals(Metadata, a, b);
  }
}

