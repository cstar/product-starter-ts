// Copyright 2020 Working Group Two AS
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file wgtwo/sms/v1/sms.proto (package wgtwo.sms.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Duration, Message, proto3 } from "@bufbuild/protobuf";

/**
 * *
 * The class of the message.
 *
 * See https://en.wikipedia.org/wiki/Data_Coding_Scheme#Message_Classes
 *
 * @generated from enum wgtwo.sms.v1.MessageClass
 */
export enum MessageClass {
  /**
   * No message class specified.
   *
   * @generated from enum value: MESSAGE_CLASS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * CLASS 0
   * A flash message is a message that is not stored on the device. It is handled
   * immediately or dropped, and also cannot be multi-fragment. Data messages of
   * this type needs a destination application port to designate what app will
   * handle it.
   *
   * @generated from enum value: MESSAGE_CLASS_FLASH_MESSAGE = 1;
   */
  FLASH_MESSAGE = 1,

  /**
   * CLASS 1
   * Mobile Equipment specific messages are handled by by an application on the
   * handset device itself, e.g. WAP push messages. Data messages of this type
   * needs a destination application port to designate what app will handle it.
   *
   * @generated from enum value: MESSAGE_CLASS_ME_SPECIFIC = 2;
   */
  ME_SPECIFIC = 2,

  /**
   * CLASS 2
   * Handled by the sim card. SIM updates have special requirements tied to the
   * SIM card itself, and must be signed with a SIM specific private key only known
   * by the operator.
   *
   * @generated from enum value: MESSAGE_CLASS_SIM_SPECIFIC = 3;
   */
  SIM_SPECIFIC = 3,

  /**
   * CLASS 3
   * Terminal Equipment specific message are handled by the handset itself, or by
   * a SIM application, and may require an application port to designate who will
   * handle it.
   *
   * @generated from enum value: MESSAGE_CLASS_TE_SPECIFIC = 4;
   */
  TE_SPECIFIC = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(MessageClass)
proto3.util.setEnumType(MessageClass, "wgtwo.sms.v1.MessageClass", [
  { no: 0, name: "MESSAGE_CLASS_UNSPECIFIED" },
  { no: 1, name: "MESSAGE_CLASS_FLASH_MESSAGE" },
  { no: 2, name: "MESSAGE_CLASS_ME_SPECIFIC" },
  { no: 3, name: "MESSAGE_CLASS_SIM_SPECIFIC" },
  { no: 4, name: "MESSAGE_CLASS_TE_SPECIFIC" },
]);

/**
 * @generated from message wgtwo.sms.v1.SendTextFromSubscriberRequest
 */
export class SendTextFromSubscriberRequest extends Message<SendTextFromSubscriberRequest> {
  /**
   * The message text content. Minimum 1 character, maximum 2000 characters. Supports
   * unicode, though completeness is dependent on the receiver handset.
   *
   * @generated from field: string content = 1;
   */
  content = "";

  /**
   * The subscriber number to send this. The sending product must have a right
   * to send as the subscriber specifically. E.g. operators can only send as
   * their own subscribers, third party products only as subscribers who have
   * enabled the product. Must be international number starting with '+'.
   *
   * @generated from field: string from_subscriber = 2;
   */
  fromSubscriber = "";

  /**
   * The destination number of the message. Can be international starting
   * with '+', short form number or network specific numbers.
   *
   * @generated from field: string to_address = 3;
   */
  toAddress = "";

  /**
   * Deadline to which the message needs to be delivered. If this is passed
   * and a delivery is not succeeded, the message delivery will fail. If not set
   * will use the maximum deadline. Maximum is 7 days.
   *
   * @generated from field: google.protobuf.Duration delivery_deadline = 4;
   */
  deliveryDeadline?: Duration;

  constructor(data?: PartialMessage<SendTextFromSubscriberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.sms.v1.SendTextFromSubscriberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "from_subscriber", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "to_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "delivery_deadline", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendTextFromSubscriberRequest {
    return new SendTextFromSubscriberRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendTextFromSubscriberRequest {
    return new SendTextFromSubscriberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendTextFromSubscriberRequest {
    return new SendTextFromSubscriberRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendTextFromSubscriberRequest | PlainMessage<SendTextFromSubscriberRequest> | undefined, b: SendTextFromSubscriberRequest | PlainMessage<SendTextFromSubscriberRequest> | undefined): boolean {
    return proto3.util.equals(SendTextFromSubscriberRequest, a, b);
  }
}

/**
 * @generated from message wgtwo.sms.v1.SendTextToSubscriberRequest
 */
export class SendTextToSubscriberRequest extends Message<SendTextToSubscriberRequest> {
  /**
   * The message text content. Minimum 1 character, maximum 2000 characters. Supports
   * unicode, though completeness is dependent on the receiver handset.
   *
   * @generated from field: string content = 1;
   */
  content = "";

  /**
   * The destination phone number of the subscriber to receive the
   * message. Must be international number starting with '+'.
   *
   * @generated from field: string to_subscriber = 2;
   */
  toSubscriber = "";

  /**
   * Origin address of the message.
   *
   * It can either be a
   * - a phone number formatted as E.164 starting with '+'.
   * - a alphanumeric sender ID.
   * - short form number.
   * - network specific number.
   *
   * Typical values here would be to send from your product's name.
   *
   * Important: Address must be pre-approved by Working Group Two.
   * See docs on origin addresses for what is allowed.
   *
   * @generated from field: string from_address = 3;
   */
  fromAddress = "";

  /**
   * Deadline to which the message needs to be delivered. If this is passed
   * and a delivery is not succeeded, the message delivery will fail. If not set
   * will use the maximum deadline. Maximum is 7 days.
   *
   * @generated from field: google.protobuf.Duration delivery_deadline = 4;
   */
  deliveryDeadline?: Duration;

  constructor(data?: PartialMessage<SendTextToSubscriberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.sms.v1.SendTextToSubscriberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "to_subscriber", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "from_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "delivery_deadline", kind: "message", T: Duration },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendTextToSubscriberRequest {
    return new SendTextToSubscriberRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendTextToSubscriberRequest {
    return new SendTextToSubscriberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendTextToSubscriberRequest {
    return new SendTextToSubscriberRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendTextToSubscriberRequest | PlainMessage<SendTextToSubscriberRequest> | undefined, b: SendTextToSubscriberRequest | PlainMessage<SendTextToSubscriberRequest> | undefined): boolean {
    return proto3.util.equals(SendTextToSubscriberRequest, a, b);
  }
}

/**
 * @generated from message wgtwo.sms.v1.SendDataToSubscriberRequest
 */
export class SendDataToSubscriberRequest extends Message<SendDataToSubscriberRequest> {
  /**
   * The binary content of the data SMS. Must be at least 1 byte, and maximum
   * 2000 bytes.
   *
   * @generated from field: bytes content = 1;
   */
  content = new Uint8Array(0);

  /**
   * The destination phone number of the subscriber to receive the
   * message. Must be international number starting with '+'.
   *
   * @generated from field: string to_subscriber = 2;
   */
  toSubscriber = "";

  /**
   * Origin address of the message.
   *
   * It can either be a
   * - a phone number formatted as E.164 starting with '+'.
   * - a alphanumeric sender ID.
   * - short form number.
   * - network specific number.
   *
   * Typical values here would be to send from your product's name.
   *
   * Important: Address must be pre-approved by Working Group Two.
   * See docs on origin addresses for what is allowed.
   *
   * @generated from field: string from_address = 3;
   */
  fromAddress = "";

  /**
   * Deadline to which the message needs to be delivered. If this is passed
   * and a delivery is not succeeded, the message delivery will fail. If not set
   * will use the maximum deadline. Maximum is 7 days.
   *
   * @generated from field: google.protobuf.Duration delivery_deadline = 4;
   */
  deliveryDeadline?: Duration;

  /**
   * The message class to use for the data SMS message.
   *
   * @generated from field: wgtwo.sms.v1.MessageClass message_class = 5;
   */
  messageClass = MessageClass.UNSPECIFIED;

  /**
   * The application port for the message.
   *
   * @generated from field: wgtwo.sms.v1.ApplicationPort application_port = 6;
   */
  applicationPort?: ApplicationPort;

  constructor(data?: PartialMessage<SendDataToSubscriberRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.sms.v1.SendDataToSubscriberRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "content", kind: "scalar", T: 12 /* ScalarType.BYTES */ },
    { no: 2, name: "to_subscriber", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "from_address", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "delivery_deadline", kind: "message", T: Duration },
    { no: 5, name: "message_class", kind: "enum", T: proto3.getEnumType(MessageClass) },
    { no: 6, name: "application_port", kind: "message", T: ApplicationPort },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendDataToSubscriberRequest {
    return new SendDataToSubscriberRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendDataToSubscriberRequest {
    return new SendDataToSubscriberRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendDataToSubscriberRequest {
    return new SendDataToSubscriberRequest().fromJsonString(jsonString, options);
  }

  static equals(a: SendDataToSubscriberRequest | PlainMessage<SendDataToSubscriberRequest> | undefined, b: SendDataToSubscriberRequest | PlainMessage<SendDataToSubscriberRequest> | undefined): boolean {
    return proto3.util.equals(SendDataToSubscriberRequest, a, b);
  }
}

/**
 * Application ports are used to send data SMS messages to specific applications
 * on the handset. If a reply to the message is sent, it should use the same
 * ports but swap originator and destination port numbers.
 *
 * @generated from message wgtwo.sms.v1.ApplicationPort
 */
export class ApplicationPort extends Message<ApplicationPort> {
  /**
   * The originator application port.
   *
   * @generated from field: uint32 originator_port = 1;
   */
  originatorPort = 0;

  /**
   * The destination application port.
   *
   * @generated from field: uint32 destination_port = 2;
   */
  destinationPort = 0;

  constructor(data?: PartialMessage<ApplicationPort>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.sms.v1.ApplicationPort";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "originator_port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
    { no: 2, name: "destination_port", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ApplicationPort {
    return new ApplicationPort().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ApplicationPort {
    return new ApplicationPort().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ApplicationPort {
    return new ApplicationPort().fromJsonString(jsonString, options);
  }

  static equals(a: ApplicationPort | PlainMessage<ApplicationPort> | undefined, b: ApplicationPort | PlainMessage<ApplicationPort> | undefined): boolean {
    return proto3.util.equals(ApplicationPort, a, b);
  }
}

/**
 * @generated from message wgtwo.sms.v1.SendMessageResponse
 */
export class SendMessageResponse extends Message<SendMessageResponse> {
  /**
   * An ID representing the message. For events etc related to the message, this ID
   * will be used in the event as identifier.
   *
   * @generated from field: string message_id = 1;
   */
  messageId = "";

  /**
   * The response status for attempting to send the message.
   *
   * @generated from field: wgtwo.sms.v1.SendMessageResponse.SendStatus status = 2;
   */
  status = SendMessageResponse_SendStatus.UNSPECIFIED;

  /**
   * Human readable description for what failed or rejected the message.
   *
   * @generated from field: string description = 3;
   */
  description = "";

  /**
   * Number of fragments sent. This is because of the underlying SMS protocols only
   * supports sending 140 bytes per message after encoding and packing. This is including
   * extra encoding info and correlation and part handling for multi-fragmented messages.
   *
   * @generated from field: uint32 num_fragments = 4;
   */
  numFragments = 0;

  constructor(data?: PartialMessage<SendMessageResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "wgtwo.sms.v1.SendMessageResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "message_id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "status", kind: "enum", T: proto3.getEnumType(SendMessageResponse_SendStatus) },
    { no: 3, name: "description", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "num_fragments", kind: "scalar", T: 13 /* ScalarType.UINT32 */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SendMessageResponse {
    return new SendMessageResponse().fromJsonString(jsonString, options);
  }

  static equals(a: SendMessageResponse | PlainMessage<SendMessageResponse> | undefined, b: SendMessageResponse | PlainMessage<SendMessageResponse> | undefined): boolean {
    return proto3.util.equals(SendMessageResponse, a, b);
  }
}

/**
 * @generated from enum wgtwo.sms.v1.SendMessageResponse.SendStatus
 */
export enum SendMessageResponse_SendStatus {
  /**
   * @generated from enum value: SEND_STATUS_UNSPECIFIED = 0;
   */
  UNSPECIFIED = 0,

  /**
   * Sending the message is accepted. Note that the message is not delivered yet.
   *
   * @generated from enum value: SEND_STATUS_OK = 1;
   */
  OK = 1,

  /**
   * Sending the message is rejected (not allowed). This may be because of
   * subscriber policy limitations, rights of the product or content of the
   * message. See description for details.
   *
   * @generated from enum value: SEND_STATUS_REJECT = 2;
   */
  REJECT = 2,

  /**
   * Sending the message failed. This error should be treated as temporary, and
   * sending the message again may work.
   *
   * @generated from enum value: SEND_STATUS_ERROR = 3;
   */
  ERROR = 3,
}
// Retrieve enum metadata with: proto3.getEnumType(SendMessageResponse_SendStatus)
proto3.util.setEnumType(SendMessageResponse_SendStatus, "wgtwo.sms.v1.SendMessageResponse.SendStatus", [
  { no: 0, name: "SEND_STATUS_UNSPECIFIED" },
  { no: 1, name: "SEND_STATUS_OK" },
  { no: 2, name: "SEND_STATUS_REJECT" },
  { no: 3, name: "SEND_STATUS_ERROR" },
]);

